require("utils")
local Lib = require("script/event_lib")
local lib = Lib.new()


local function map_zone_indexes(indexes)
	if indexes == nil then return {} end
	local result = {}
	for i = 1, #indexes do
		result[#result + 1] = remote.call("space-exploration", "get_zone_from_zone_index", {zone_index = indexes[i]})
	end
	return result
end


function lib.rebuild_planets_cache()
	local zone_n = remote.call("space-exploration", "get_zone_from_name", {zone_name = "Nauvis"})
	local zone_s = remote.call("space-exploration", "get_zone_from_zone_index", {zone_index = zone_n.parent_index})
	local zones_ns = map_zone_indexes(zone_s.child_indexes)

	global.home_zones = {}
	table.extend(global.home_zones, zones_ns)
	for i = 1, #zones_ns do
		table.extend(global.home_zones, map_zone_indexes(zones_ns[i].child_indexes))
	end
	global.all_zones = remote.call("space-exploration", "get_zone_index", {})
	if WSEK_DEBUG then
		game.print("Nauvis have "..#zones_ns.." siblings: "..serpent.line(zone_s.child_indexes))
		game.print("SE universe have "..#global.all_zones.." planets")
	end
end


local safe_ores = {
	-- Allow Vanilla resource on any planet
	["coal"]=1, ["stone"]=1, ["copper-ore"]=1, ["iron-ore"]=1, ["uranium-ore"]=1, ["crude-oil"]=1,
	-- Krastorio too?..
	["mineral-water"]=1, ["rare-metals"]=1,
}

local function cleanup_planetorio_resource_mgs(dict)
	local removed = {}
	local should_remove
	for name, values in pairs(dict) do
		should_remove = game.entity_prototypes[name] ~= nil and safe_ores[name] == nil
		should_remove = should_remove and math.random(1, 100) > settings.global["sekw-modded-ores-chance"].value
		if should_remove then
			dict[name].frequency = 0
			dict[name].richness = -1
			table.append(removed, name)
		end
	end
	if #removed > 0 and WSEK_DEBUG then
		game.print("Removed "..#removed.." SE+K2 ores: "..serpent.line(removed))
	end
end

local function handle_surface_by_planetorio(surface)
	-- Remove most of SE+K2 ores, it's too crazy to have everything together
	-- local surface = game.surfaces[remote.call("warptorio","GetMainSurface").index]
	local mgs = surface.map_gen_settings
	cleanup_planetorio_resource_mgs(mgs.autoplace_controls)
	-- cleanup_planetorio_resource_mgs(mgs.autoplace_settings.entity.settings)
	surface.map_gen_settings = mgs
	-- log("Fixed WSEK surface:\n"..serpent.block(mgs))
	
end

local function on_surface_created(event)
	-- Catch when surface is generated by Planetorio
	local surface = game.surfaces[event.surface_index]
	game.print("WSEK got on_surface_created event: "..surface.name)
	if surface.name:find("warpzone", 1, true) then
		handle_surface_by_planetorio(surface)
	end
end


remote.add_interface("WSEK", {
	-- Link W2 with SE
	warptorio2_provide_planet = function(args)
		if WSEK_DEBUG then
			game.print("WSEK got warptorio2_provide_planet event: "..serpent.line(args))
		end

		if math.random(1, 100) > settings.global["sekw-se-teleport-chance"].value then return nil end

		if not global.all_zones or not global.home_zones or #global.home_zones==0 then
			lib.rebuild_planets_cache()
		end

		local zone
		if math.random(1, 100) <= settings.global["sekw-nauvis-teleport-chance"].value then
			zone = global.home_zones[math.random(1, #global.home_zones)]
		else
			zone = global.all_zones[math.random(1, #global.all_zones)]
		end

		local surface = remote.call("space-exploration", "zone_get_make_surface", {zone_index = zone.index})
		-- remote.call("space-exploration", "discover_zone", {force_name = game.player.force.name, surface=nil, zone_name=zone.name})

		surface.request_to_generate_chunks({0, 0}, 5) surface.force_generate_chunk_requests()

		if game.forces.player.technologies["warptorio-charting"].researched then
			remote.call("space-exploration", "discover_zone", {force_name = game.player.force.name, surface=surface, zone_name=zone.name})
		end

		local warp_multiply = nil
		warp_multiply = math.max(1,
			(zone.star_gravity_well or 0) / 10 + (zone.planet_gravity_well or 0) / 5
		)

		return {
			surface = surface,
			planet = {
				name = zone.name,
				desc = nil,
				warp_multiply = warp_multiply,
			},
			force = nil,
		}
	end,

	 -- Prevent SE from deleting the surface with W2 platform
	 space_exploration_delete_surface = function(event)
			if event.surface_index == remote.call("warptorio","GetMainSurface").index then
				 return {
					 allow_delete=false,
					 message="Warptorio Reactor is there!",  -- TODO: replace this text
					 -- message={"mod-name.surface-deletion-forbidden"},
				 }
			end
	 end,
})


lib:on_init(lib.rebuild_planets_cache)
-- lib:on_load(lib.rebuild_planets_cache)
lib:on_configuration_changed(lib.rebuild_planets_cache)
lib:on_event(defines.events.on_surface_created, on_surface_created)

return lib